<html>
  <head>
    <script src="https://d3js.org/d3.v6.min.js"></script>
  </head>
  <body>
    <style>
      .gridlines line {
        stroke: #bbb;
      }
      .gridlines .domain {
        stroke: none;
      }
    </style>
    <svg id="lineGraph" height="500" width="1000"></svg>
    <svg id="scatterPlot" height="500" width="1000"></svg>
    <svg id="scatterPlot4" height="500" width="1000"></svg>
    <svg id="barChart" height="500" width="1000"></svg>
    <script>
      //lineGraph happiness vs year
      const svgLineGraph = d3.select("svg#lineGraph");
      const height1 = svgLineGraph.attr("height");
      const width1 = svgLineGraph.attr("width");
      const margin = { top: 10, right: 10, bottom: 50, left: 70 };
      const chartWidth1 = width1 - margin.left - margin.right;
      const chartHeight1 = height1 - margin.top - margin.bottom;
      let annotations1 = svgLineGraph.append("g").attr("id", "annotations1");
      let chartArea1 = svgLineGraph
        .append("g")
        .attr("id", "chart1")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      const accessData = async function () {
        const allData = await d3.csv("data.csv");
        let data = await d3.csv("data_by_year.csv");
        const happinessYear = await d3.csv("data_by_year.csv");
        const byGenre = await d3.csv("data_by_genres.csv");

        data = data.filter((d) => d["year"] != "2021");

        const timeParser = d3.timeParse("%Y");

        data.forEach((d) => {
          d["year_date"] = timeParser(d["year"]);
        });

        allData.forEach((d) => {
          d["year_date"] = timeParser(d["year"]);
        });

        // get extent and scales
        const dateExtent = d3.extent(data, (d) => d["year_date"]);
        const dateScale = d3
          .scaleTime()
          .domain(dateExtent)
          .range([0, chartWidth1]);

        const happinessExtent = d3.extent(data, (d) => d["acousticness"]);
        const happinessScale = d3
          .scaleLinear()
          .domain([0, 1])
          .range([chartHeight1, 0]);

        //x-axis
        let xAxis1 = d3.axisBottom(dateScale);
        let xGridlines1 = d3
          .axisBottom(dateScale)
          .tickSize(-chartHeight1 - 10)
          .tickFormat("");

        //y-axis
        let yAxis1 = d3.axisLeft(happinessScale);
        let yGridlines1 = d3
          .axisLeft(happinessScale)
          .tickSize(-chartWidth1 - 10)
          .tickFormat("");

        annotations1
          .append("g")
          .attr("class", "y axis")
          .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
          .call(yAxis1);

        annotations1
          .append("g")
          .attr("class", "y gridlines")
          .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
          .call(yGridlines1);

        annotations1
          .append("g")
          .attr("class", "x axis")
          .attr(
            "transform",
            `translate(${margin.left}, ${chartHeight1 + margin.top + 10})`
          )
          .call(xAxis1);

        annotations1
          .append("g")
          .attr("class", "x gridlines")
          .attr(
            "transform",
            `translate(${margin.left}, ${chartHeight1 + margin.top + 10})`
          )
          .call(xGridlines1);

        //line generator

        let lineGenerator = d3
          .line()
          .x((d) => dateScale(d["year_date"]))
          .y((d) => happinessScale(d["acousticness"]))
          .curve(d3.curveMonotoneX);

        //add line to graph

        chartArea1
          .append("path")
          .datum(data)
          .attr("class", "line")
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 3)
          .attr("d", lineGenerator);

        //scatterPlot happiness vs popularity
        const svgScatterPlot = d3.select("svg#scatterPlot");
        const height2 = svgScatterPlot.attr("height");
        const width2 = svgScatterPlot.attr("width");
        const chartWidth2 = width2 - margin.left - margin.right;
        const chartHeight2 = height2 - margin.top - margin.bottom;
        let annotations2 = svgScatterPlot
          .append("g")
          .attr("id", "annotations2");
        let chartArea2 = svgScatterPlot
          .append("g")
          .attr("id", "chart1")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        //x scale popularity
        const popExtent = d3.extent(allData, (d) => d["popularity"]);
        const popScale = d3
          .scaleLinear()
          .domain(popExtent)
          .range([chartHeight2, 0]);

        //y scale is above

        //x axis
        let bottomAxis2 = d3.axisBottom(dateScale);

        let bottomGridlines2 = d3
          .axisBottom(dateScale)
          .tickSize(-chartHeight2 - 10)
          .tickFormat("");

        let leftAxis2 = d3.axisLeft(popScale);
        let leftGridlines2 = d3
          .axisLeft(popScale)
          .tickSize(-chartWidth2 - 10)
          .tickFormat("");
        annotations2
          .append("g")
          .attr("class", "y axis")
          .attr("transform", `translate(${margin.left - 10},${margin.top})`)
          .call(leftAxis2);
        annotations2
          .append("g")
          .attr("class", "y gridelines")
          .attr("transform", `translate(${margin.left - 10},${margin.top})`)
          .call(leftGridlines2);
        annotations2
          .append("g")
          .attr("class", "x axis")
          .attr(
            "transform",
            `translate(${margin.left},${chartHeight2 + margin.top + 10})`
          )
          .call(bottomAxis2);
        annotations2
          .append("g")
          .attr("class", "x gridlines")
          .attr(
            "transform",
            `translate(${margin.left},${chartHeight2 + margin.top + 10})`
          )
          .call(bottomGridlines2);
        //add circles
        let points = chartArea2
          .selectAll("circle")
          .data(allData)
          .join("circle")
          .attr("class", "circles")
          .attr("cx", (d) => dateScale(d["year_date"]))
          .attr("cy", (d) => popScale(d["popularity"]))
          .attr("r", 3)
          .attr("fill", "goldenrod")
          .attr("id", (d) => d.popularity);

        //barChart happiness vs genre
        const svgBarChart = d3.select("svg#barChart");
        const height3 = svgBarChart.attr("height");
        const width3 = svgBarChart.attr("width");
        const chartWidth3 = width3 - margin.left - margin.right;
        const chartHeight3 = height3 - margin.top - margin.bottom;

        let chartArea3 = svgBarChart
          .append("g")
          .attr("id", "points")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        let topTen = byGenre.sort(function (a, b) {
          return b.popularity - a.popularity;
        });
        topTen = topTen.slice(0, 10);

        const genres = d3.map(topTen, (d) => d["genres"]);
        const genreScale3 = d3
          .scaleBand()
          .domain(genres)
          .range([0, chartWidth3])
          .padding(0.05);

        const popExtent3 = d3.extent(byGenre, (d) => d["popularity"]);
        const popScale3 = d3
          .scaleLinear()
          .domain([
            byGenre[byGenre.length - 1].popularity,
            byGenre[0].popularity,
          ])
          .range([chartHeight3, 0]);

        console.log(popExtent3);

        let annotations3 = svgBarChart.append("g").attr("id", "annotations3");

        let yAxis3 = d3.axisLeft(popScale3);
        let yAxisGridlines3 = d3
          .axisLeft(popScale3)
          .tickSize(-chartWidth3 - 10)
          .tickFormat("");

        annotations3
          .append("g")
          .attr("class", "y axis")
          .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
          .call(yAxis3);

        annotations3
          .append("g")
          .attr("class", "y gridlines")
          .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
          .call(yAxisGridlines3);

        let xAxis3 = d3.axisBottom(genreScale3);

        annotations3
          .append("g")
          .attr("class", "x axis")
          .attr(
            "transform",
            `translate(${margin.left}, ${chartHeight3 + margin.top + 10})`
          )
          .call(xAxis3);

        chartArea3
          .selectAll("rect.bar")
          .data(topTen)
          .join("rect")
          .attr("class", "bar")
          .attr("fill", "steelblue")
          .attr("x", (d) => genreScale3(d["genres"]))
          .attr("y", (d) => popScale3(d["popularity"]))
          .attr(
            "height",
            (d) => popScale3(popExtent3[0]) - popScale3(d["popularity"])
          )
          .attr("width", genreScale3.bandwidth());

          //happiness vs popularity START HERE
          const svgScatterPlot4 = d3.select("svg#scatterPlot4");
          const height4 = svgScatterPlot4.attr("height");
          const width4 = svgScatterPlot4.attr("width");
          const chartWidth4 = width4 - margin.left - margin.right;
          const chartHeight4 = height4 - margin.top - margin.bottom;
          let annotations4 = svgScatterPlot4
            .append("g")
            .attr("id", "annotations4");
          let chartArea4 = svgScatterPlot4
            .append("g")
            .attr("id", "chart4")
            .attr("transform", `translate(${margin.left},${margin.top})`);

          //x scale popularity
          // const popExtent = d3.extent(allData, (d) => d["popularity"]);
          // const popScale = d3
          //   .scaleLinear()
          //   .domain(popExtent)
          //   .range([chartHeight4, 0]);

          //y scale is above happiness

          //x axis
          let bottomAxis4 = d3.axisBottom(happinessScale);

          let bottomGridlines4 = d3
            .axisBottom(happinessScale)
            .tickSize(-chartHeight4 - 10)
            .tickFormat("");

          let leftAxis4 = d3.axisLeft(popScale);
          let leftGridlines4 = d3
            .axisLeft(popScale)
            .tickSize(-chartWidth4 - 10)
            .tickFormat("");
          annotations4
            .append("g")
            .attr("class", "y axis")
            .attr("transform", `translate(${margin.left - 10},${margin.top})`)
            .call(leftAxis4);
          annotations4
            .append("g")
            .attr("class", "y gridelines")
            .attr("transform", `translate(${margin.left - 10},${margin.top})`)
            .call(leftGridlines4);
          annotations4
            .append("g")
            .attr("class", "x axis")
            .attr(
              "transform",
              `translate(${margin.left},${chartHeight4 + margin.top + 10})`
            )
            .call(bottomAxis4);
          annotations4
            .append("g")
            .attr("class", "x gridlines")
            .attr(
              "transform",
              `translate(${margin.left},${chartHeight4 + margin.top + 10})`
            )
            .call(bottomGridlines4);
          //add circles
          let points4 = chartArea4
            .selectAll("circle")
            .data(allData)
            .join("circle")
            .attr("class", "circles")
            .attr("cx", (d) => happinessScale(d["acousticness"]))
            .attr("cy", (d) => popScale(d["popularity"]))
            .attr("r", 3)
            .attr("fill", "goldenrod")
            .attr("id", (d) => d.popularity);

      };
      accessData();
    </script>
  </body>
</html>
