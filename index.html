<html>
  <head>
    <script src="https://d3js.org/d3.v6.min.js"></script>
  </head>
  <body>
    <style>
      .gridlines line {
        stroke: #bbb;
      }
      .gridlines .domain {
        stroke: none;
      }
    </style>
    <p>How has</p>
    <svg id="lineGraph" height="500" width="1200"></svg>
    <div class="bar-graphs">
      <svg id="g1" height="500" width="400"></svg>
      <svg id="g2" height="500" width="400"></svg>
      <svg id="g3" height="500" width="400"></svg>
    </div>
    <script>
      //lineGraph happiness vs year
      const svgLineGraph = d3.select("svg#lineGraph");
      let height = svgLineGraph.attr("height");
      let width = svgLineGraph.attr("width");
      const margin = { top: 10, right: 20, bottom: 50, left: 70 };
      let chartWidth = width - margin.left - margin.right;
      let chartHeight = height - margin.top - margin.bottom;
      let annotations = svgLineGraph.append("g").attr("id", "annotations1");
      let chartArea = svgLineGraph
        .append("g")
        .attr("id", "chart1")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // stringLen function from Lecture 3/17 by Professor Jeff Rezertoski
      // Legend
      let legend = chartArea
        .append("g")
        .attr("transform", `translate(${chartWidth - 130}, ${margin.top})`)
        .attr("class", "legend");

      const legendFrame = legend
        .append("rect")
        .attr("class", "frame")
        .attr("x", 0)
        .attr("y", 0)
        .attr("rx", 10)
        .attr("ry", 10)
        .attr("height", 70)
        .attr("width", 127)
        .attr("fill", "white")
        .attr("stroke-width", "1px")
        .attr("stroke", "black");

      const accessData = async function () {
        let allData = await d3.csv("data.csv");
        let data = await d3.csv("data_by_year.csv");
        let gData = await d3.csv("data_by_genres.csv");

        data = data.filter((d) => d["year"] != "2021");

        let timeParser = d3.timeParse("%Y");

        data.forEach((d) => {
          d["year_date"] = timeParser(d["year"]);
          d["popularity_scaled"] = d["popularity"] / 100;
        });

        // get extent and scales
        const dateExtent = d3.extent(data, (d) => d["year_date"]);

        let dateScale = d3
          .scaleTime()
          .domain(dateExtent)
          .range([0, chartWidth]);

        let musicMeasureScale = d3
          .scaleLinear()
          .domain([0, 1])
          .range([chartHeight, 0]);

        const colorExtent = [
          "energy",
          "valence",
          "danceability",
          "instrumentalness",
        ];
        let barColorScale = d3
          .scaleOrdinal()
          .domain(colorExtent)
          .range(d3.schemeCategory10);

        let j = 15;
        for (let i = 0; i < colorExtent.length; i++) {
          legend
            .append("text")
            .text(colorExtent[i])
            .style("fill", barColorScale(colorExtent[i]))
            .style("font-family", "Arial")
            .attr("x", 5)
            .attr("y", j);
          j += 15;
        }
        //x-axis
        let xAxis1 = d3.axisBottom(dateScale);
        let xGridlines1 = d3
          .axisBottom(dateScale)
          .tickSize(-chartHeight - 10)
          .tickFormat("");

        //y-axis
        let yAxis1 = d3.axisLeft(musicMeasureScale);
        let yGridlines1 = d3
          .axisLeft(musicMeasureScale)
          .tickSize(-chartWidth - 10)
          .tickFormat("");

        annotations
          .append("g")
          .attr("class", "y axis")
          .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
          .call(yAxis1);

        annotations
          .append("g")
          .attr("class", "y gridlines")
          .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
          .call(yGridlines1);

        annotations
          .append("g")
          .attr("class", "x axis")
          .attr(
            "transform",
            `translate(${margin.left}, ${chartHeight + margin.top + 10})`
          )
          .call(xAxis1);

        annotations
          .append("g")
          .attr("class", "x gridlines")
          .attr(
            "transform",
            `translate(${margin.left}, ${chartHeight + margin.top + 10})`
          )
          .call(xGridlines1);

        //line generator
        let variables = [
          "energy",
          "valence",
          "danceability",
          "instrumentalness",
        ];

        variables.forEach((i) => {
          let lineGen = d3
            .line()
            .x((d) => dateScale(d["year_date"]))
            .y((d) => musicMeasureScale(d[i]))
            .curve(d3.curveMonotoneX);

          console.log(i);
          chartArea
            .append("path")
            .datum(data)
            .attr("class", "line")
            .attr("fill", "none")
            .attr("stroke", barColorScale(i))
            .attr("stroke-width", 3)
            .attr("d", (d) => lineGen(d))
            .attr("id", i);
        });

        function createGenreGraph(gId, genre) {
          const svg = d3.select("svg#" + gId);
          const height = svg.attr("height");
          const width = svg.attr("width");
          const chartWidth = width - margin.left - margin.right;
          const chartHeight = height - margin.top - margin.bottom;
          let annotations = svg.append("g").attr("id", "annotations");
          let chartArea = svg
            .append("g")
            .attr("id", "chart")
            .attr("transform", `translate(${margin.left},${margin.top})`);

          // x scale (attributes)

          const xScale = d3
            .scaleBand()
            .domain(colorExtent) // colorExtent == all measures
            .range([0, chartWidth])
            .padding(0.1);
          // y scale is musicMeasureScale already defined above.
          // y axis / grids
          annotations
            .append("g")
            .attr("class", "y axis")
            .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
            .call(yAxis1);

          annotations
            .append("g")
            .attr("class", "y gridlines")
            .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
            .call(yGridlines1);

          // x axix / grids
          let xAxis = d3.axisBottom(xScale);

          annotations
            .append("g")
            .attr("class", "x axis")
            .attr(
              "transform",
              `translate(${margin.left}, ${chartHeight + margin.top + 10})`
            )
            .call(xAxis);

          // get specific genre-level data
          let genreData = gData.filter((d) => d["genres"] === genre);
          console.log(genreData);
          let metrics = [
            [genreData[0].energy, "energy"],
            [genreData[0].valence, "valence"],
            [genreData[0].danceability, "danceability"],
            [genreData[0].instrumentalness, "instrumentalness"],
          ];
          console.log(metrics);
          chartArea
            .selectAll("rect#bar")
            .data(metrics)
            .join("rect")
            .attr("class", "bar")
            .attr("fill", (d) => barColorScale(d[1]))
            .attr("x", (d) => xScale(d[1]))
            .attr("y", (d) => musicMeasureScale(d[0]))
            .attr(
              "height",
              (d) => musicMeasureScale(0) - musicMeasureScale(d[0])
            )
            .attr("width", (d) => xScale.bandwidth());

          // valence values
        }
        createGenreGraph("g1", "classical");
        createGenreGraph("g2", "pop");
        createGenreGraph("g3", "rock");

        console.log(gData.filter((d) => d["genres"] === "hip hop"));
      };
      accessData();
    </script>
  </body>
</html>
